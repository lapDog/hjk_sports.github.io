<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[Java容器知识总结]]></title>
    <url>%2Fblog%2FJava%E5%AE%B9%E5%99%A8%E7%9F%A5%E8%AF%86%E6%80%BB%E7%BB%93%2F</url>
    <content type="text"><![CDATA[Java集合框架提供了一套性能优良，使用方便的接口和类，这里统称为容器。Java容器包位于java.util包中，主要包含了常用的数据结构：集合、链表、队列、栈、数组、映射等实现。在日常工作中，Java容器是必须掌握的基础知识，深入理解具体实现有助于编码效率提升以及少踩坑。本文将对Java容器进行详细的分析，包括容器对比(性能、线程安全等)、源码剖析、常用场景分析等。 总述首先我们对Java容器进行整体归纳，如下图所示： 从上图可看出Java容器可具体细分： Collection接口，主要包括了List接口及其实现、Set接口及其实现、Queue接口及实现。 Map接口及具体实现。 CollectionCollection接口下具体实现了List、Set及Queue，本节将对各成员及实现进行对比和总体总结。 ListList线性、有序不唯一的存储容器，可通过索引访问元素get(n)。具体的实现类及相关对比如下： 实现类 实现类特性 适用场景 ArrayList 数组实现、线程不安全 读多写少 LinkedList 双向链表实现、线程不安全 写多读少 Vector 类似ArrayList,线程安全 已过时，不建议使用！ Map简述Map中包含的东西，各个成员对比，性能等。对常用成员进行源码级剖析 JUC容器对juc包中的容器进行源码级剖析 #总结]]></content>
      <categories>
        <category>Java基础</category>
      </categories>
      <tags>
        <tag>Java基础</tag>
        <tag>Java容器</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java 23种设计模式]]></title>
    <url>%2Fblog%2F20200105-Java23%E7%A7%8D%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%2F</url>
    <content type="text"><![CDATA[设计模式（Design pattern）代表了最佳的实践，通常被有经验的面向对象的软件开发人员所采用。设计模式是软件开发人员在软件开发过程中面临的一般问题的解决方案。这些解决方案是众多软件开发人员经过相当长的一段时间的试验和错误总结出来的。 设计模式是一套被反复使用的、多数人知晓的、经过分类编目的、代码设计经验的总结。使用设计模式是为了重用代码、让代码更容易被他人理解、保证代码可靠性。 毫无疑问，设计模式于己于他人于系统都是多赢的，设计模式使代码编制真正工程化，设计模式是软件工程的基石，如同大厦的一块块砖石一样。项目中合理地运用设计模式可以完美地解决很多问题，每种模式在现实中都有相应的原理来与之对应，每种模式都描述了一个在我们周围不断重复发生的问题，以及该问题的核心解决方案，这也是设计模式能被广泛应用的原因。 以上都是一些类似官方的定义，概念的东西就不多说了，若想系统了解可以百度。在讨论设计模式之前，我们先看看设计模式的六大原则: 开闭原则（Open Close Principle）开闭原则的意思是,对扩展开放，对修改关闭。在程序需要进行拓展的时候，不能去修改原有的代码，实现一个热插拔的效果。简言之，是为了使程序的扩展性好，易于维护和升级。想要达到这样的效果，我们需要使用接口和抽象类，后面的具体设计中我们会提到这点。 里氏代换原则（Liskov Substitution Principle）里氏代换原则是面向对象设计的基本原则之一。 里氏代换原则中说，任何基类可以出现的地方，子类一定可以出现。LSP 是继承复用的基石，只有当派生类可以替换掉基类，且软件单位的功能不受到影响时，基类才能真正被复用，而派生类也能够在基类的基础上增加新的行为。里氏代换原则是对开闭原则的补充。实现开闭原则的关键步骤就是抽象化，而基类与子类的继承关系就是抽象化的具体实现，所以里氏代换原则是对实现抽象化的具体步骤的规范。 依赖倒转原则（Dependence Inversion Principle）这个原则是开闭原则的基础，具体内容：针对接口编程，依赖于抽象而不依赖于具体。 接口隔离原则（Interface Segregation Principle）这个原则的意思是,使用多个隔离的接口，比使用单个接口要好。它还有另外一个意思是：降低类之间的耦合度。由此可见，其实设计模式就是从大型软件架构出发、便于升级和维护的软件设计思想，它强调降低依赖，降低耦合。 迪米特法则，又称最少知道原则（Demeter Principle）最少知道原则是指：一个实体应当尽量少地与其他实体之间发生相互作用，使得系统功能模块相对独立。 合成复用原则（Composite Reuse Principle）合成复用原则是指：尽量使用合成/聚合的方式，而不是使用继承。 设计模式都是严格或尽可能的按照这六大原则进行设计，当然我们实际工作种可能进行妥协而不会严格遵守，但是这些原则就像是一个尺标。接下来我们从整体去看设计模式之间的区别和联系并进行分类，具体如下： 设计模式分类23种设计模式可以总体可以分为三种: 创建型模式（Creational Patterns）、结构型模式（Structural Patterns）、行为型模式（Behavioral Patterns）。具体包含模式如下: 模式&amp;描述 包含模式 创建型模式(5种) 这些设计模式提供了一种在创建对象的同时隐藏创建逻辑的方式，而不是使用 new 运算符直接实例化对象。这使得程序在判断针对某个给定实例需要创建哪些对象时更加灵活。 单例模式（Singleton Pattern） 工厂模式（Factory Pattern） 抽象工厂模式（Abstract Factory Pattern） 建造者模式（Builder Pattern） 原型模式（Prototype Pattern） 结构型模式(7种) 这些设计模式关注类和对象的组合。继承的概念被用来组合接口和定义组合对象获得新功能的方式。 适配器模式（Adapter Pattern） 装饰器模式（Decorator Pattern） 代理模式（Proxy Pattern） 外观模式（Facade Pattern） 桥接模式（Bridge Pattern） 组合模式（Composite Pattern） 享元模式（Flyweight Pattern） 行为型模式(11种) 这些设计模式特别关注对象之间的通信。 策略模式（Strategy Pattern） 模板模式（Template Pattern） 观察者模式（Observer Pattern） 责任链模式（Chain of Responsibility Pattern） 命令模式（Command Pattern） 解释器模式（Interpreter Pattern） 迭代器模式（Iterator Pattern） 中介者模式（Mediator Pattern） 备忘录模式（Memento Pattern） 状态模式（State Pattern） 访问者模式（Visitor Pattern） 各种设计模式之间的联系如下： 当然并不只有这23种设计模式，实际工作中也不并不是每一种设计模式都有用到。接下来，我将举例一些常用的设计模式并用源码的方式来说明这些模式的原理、实现及适用场景。 创建型模式常用模式详解创建型模式中的各种模式真的非常常见，我们将一个个进行详细阐述。 单例模式（Singleton Pattern）“保证一个类仅有一个实例，并提供一个访问它的全局访问点。” ——《设计模式》(艾迪生维斯理, 1994) 单例就是整个程序有且仅有一个实例。该类负责创建自己的对象，同时确保只有一个对象被创建。在Java，一般常用在工具类的实现或创建对象需要消耗资源。 单例模式优点 保证全局只有一个实例，可以一定程度保证实例的资源调用(受控访问)。 在内存里只有一个实例，减少了内存的开销，尤其是频繁的创建和销毁实例。 因为由类自己来控制实例化进程，类就在改变实例化进程上有相应的伸缩性。 单例模式缺点 与单一职责冲突。 扩展性差，无法继承。 单例模式实现条件 私有的构造器。 对外提供获取实例的静态方法。 在内部产生本类的私有实例化对象。 单例模式的各种实现懒汉模式可以满足基本要求，延迟初始化，但是线程不安全。 1234567891011121314151617181920212223242526272829package indi.hjk.studydemo.Singleton;/** * 单例模式-简单单例实现 * @author HJK * @date 2020/1/6 16:21 */public class Singleton &#123; //持有私有静态实例，防止被引用，此处赋值为null，目的是实现延迟加载(懒汉) private static Singleton instance = null; //私有构造方法，防止被实例化 private Singleton() &#123; &#125; //静态工程方法，创建实例 public static Singleton getInstance()&#123; if(instance == null)&#123; instance = new Singleton(); &#125; return instance; &#125; //如果该对象被用于序列化，可以保证对象在序列化前后保持一致 public Object readResolve()&#123; return instance; &#125;&#125; 饿汉模式线程安全，比较常用，但容易产生垃圾，因为一开始就初始化。 123456789101112public class Singleton &#123; //直接初始化实例 private static Singleton instance = new Singleton(); private Singleton ()&#123; &#125; public static Singleton getInstance() &#123; return instance; &#125; &#125; 双重锁模式(Double Check Lock)线程安全，延迟初始化。这种方式采用双锁机制，安全且在多线程情况下能保持高性能。 123456789101112131415161718192021public class Singleton &#123; //使用volatile保证线程可见性、防止JVM指令重排 private volatile static Singleton singleton; private Singleton ()&#123; &#125; public static Singleton getSingleton() &#123; //第一次检查防止重新进入创建实例加锁，一定程度保证了性能 if (singleton == null) &#123; synchronized (Singleton.class) &#123; //进行同步，避免多线程问题 if (singleton == null) &#123; singleton = new Singleton(); &#125; &#125; &#125; return singleton; &#125; &#125; 静态内部类模式线程安全，只有一个线程可以获得对象的初始化锁，其他线程无法进行初始化，保证对象的唯一性。 1234567891011121314public class Singleton &#123; private Singleton()&#123; &#125; public static Singleton getInstance()&#123; return Inner.instance; &#125; //静态内部类，保证实例唯一性 private static class Inner &#123; private static final Singleton instance = new Singleton(); &#125; &#125; 枚举类模式它不仅能避免多线程同步问题，而且还自动支持序列化机制，防止反序列化重新创建新的对象，绝对防止多次实例化。 1234567891011121314151617181920212223public class User &#123; //私有化构造函数 private User()&#123; &#125; //定义一个静态枚举类 static enum SingletonEnum&#123; //创建一个枚举对象，该对象天生为单例 INSTANCE; private User user; //私有化枚举的构造函数 private SingletonEnum()&#123; user=new User(); &#125; public User getInstnce()&#123; return user; &#125; &#125; //对外暴露一个获取User对象的静态方法 public static User getInstance()&#123; return SingletonEnum.INSTANCE.getInstnce(); &#125;&#125; 使用单例模式的源码剖析使用单例模式情况较为广泛，举例JDK源码中，如Runtime类可以获得应用运行时的一些状态（主要包括使用的内存和cpu个数）和在应用运行时执行一些操作，此类就使用了单例模式。 1234567891011121314151617181920212223242526272829303132333435package java.lang;/** * Every Java application has a single instance of class * &lt;code&gt;Runtime&lt;/code&gt; that allows the application to interface with * the environment in which the application is running. The current * runtime can be obtained from the &lt;code&gt;getRuntime&lt;/code&gt; method. * &lt;p&gt; * An application cannot create its own instance of this class. * * @author unascribed * @see java.lang.Runtime#getRuntime() * @since JDK1.0 */public class Runtime &#123; private static Runtime currentRuntime = new Runtime(); /** * Returns the runtime object associated with the current Java application. * Most of the methods of class &lt;code&gt;Runtime&lt;/code&gt; are instance * methods and must be invoked with respect to the current runtime object. * * @return the &lt;code&gt;Runtime&lt;/code&gt; object associated with the current * Java application. */ public static Runtime getRuntime() &#123; return currentRuntime; &#125; /** Don't let anyone else instantiate this class */ private Runtime() &#123;&#125; //以下代码省略...&#125; 单例模式总结总体来说，单例模式在实际工作中可以说是最为常用的设计模式之一了。主要用于需要实例唯一的情况使用，以上总结了常见的单例模式实现方式。此外还需要注意一些问题: “单元素的枚举类型已经成为实现Singleton的最佳方法。” – 出自 《effective java》 实际使用中，枚举可能导致代码阅读性较差，可选择静态内部类模式。 “任何一个readObject方法，不管是显式的还是默认的，它都会返回一个新建的实例，这个新建的实例不同于该类初始化时创建的实例。” 如果单例实例需要序列化支持，需要重写readResolve方法（枚举除外）。 工厂模式（Factory Pattern）工厂模式分为简单工厂模式，工厂方法模式和抽象工厂模式，它们都属于设计模式中的创建型模式。我们在创建对象时不会对客户端直接暴露创建逻辑，而是通过使用一个共同的接口根据不同的条件来指向具体想要创建的对象。其主要功能都是帮助我们把对象的实例化部分抽取了出来，目的是降低系统中代码耦合度，并且增强了系统的扩展性。 简单工厂模式简单工厂模式最大的优点在于实现对象的创建和对象的使用分离，将对象的创建交给专门的工厂类负责，但是其最大的缺点在于工厂类不够灵活，增加新的具体产品需要修改工厂类的判断逻辑代码，而且产品较多时，工厂方法代码逻辑将会非常复杂。 举例：我们来模拟上帝造人的例子吧。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192939495969798// 1. 先定义一个人类接口/** * 工厂模式-人类接口 * @author HJK * @date 2020/1/6 16:38 */public interface Human &#123; /** * 定义人类会说话的方法 */ void say();&#125;//2. 对人类接口具体实现两个类，男人和女人。/** * 人类接口具体实现类-男人 * @author HJK * @date 2020/1/6 19:57 */public class Man implements Human &#123; @Override public void say() &#123; System.out.println("i am man!"); &#125;&#125;/** * 人类接口具体实现类-女人 * @author HJK * @date 2020/1/6 19:57 */public class Woman implements Human &#123; @Override public void say() &#123; System.out.println("i am woman !"); &#125;&#125;//3. 定义人类生产工厂，用于生产各种人。/** * 人类生产工厂类 * @author HJK * @date 2020/1/6 19:59 */public class HumanFactory &#123; /** * 人类生产方法，只要传入指定类型我就可以造人哦！ * @param type 0女人 1男人 * @return 返回人类具体实现 */ public Human produce(Integer type)&#123; if(type == 0)&#123; return new Woman(); &#125;else if(type == 1)&#123; return new Man(); &#125;else&#123; System.out.println("不合法的参数类型"); return null; &#125; &#125;&#125;//4. 编写测试类，进行结果测试。/** * 人类简单工厂模式测试 * @author HJK * @date 2020/1/6 20:05 */public class FactoryTest &#123; public static void main(String[] args) &#123; HumanFactory humanSimpleFactory = new HumanFactory(); Human woman = humanSimpleFactory.produce(0); Human man = humanSimpleFactory.produce(1); woman.say(); man.say(); &#125;&#125;//5. 结果输出i am woman !i am man! 多工厂模式多个工厂方法模式，是对普通工厂方法模式的改进，在普通工厂方法模式中，如果传递的字符串出错，则不能正确创建对象，而多个工厂方法模式是提供多个工厂方法，分别创建对象。 举例：上帝发现了上面的问题，进行了优化。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970//1.上帝将男人女人生产方法进行拆分，并标记原有的生产方法过时/** * 人类生产工厂类 * @author HJK * @date 2020/1/6 19:59 */public class HumanFactory &#123; /** * 人类生产方法，只要传入指定类型我就可以造人哦！ * @param type 0女人 1男人 * @return 返回人类具体实现 */ @Deprecated public Human produce(Integer type)&#123; if(type == 0)&#123; return new Woman(); &#125;else if(type == 1)&#123; return new Man(); &#125;else&#123; System.out.println("不合法的参数类型"); return null; &#125; &#125; /** * 生产男人的工厂方法 * @return */ public Human producWoman()&#123; return new Woman(); &#125; /** * 生产女人的工厂方法 * @return */ public Human produceMan()&#123; return new Man(); &#125;&#125;//2. 编写测试类，进行结果测试。/** * 人类简单工厂模式测试 * @author HJK * @date 2020/1/6 20:05 */public class FactoryTest &#123; public static void main(String[] args) &#123; HumanFactory humanSimpleFactory = new HumanFactory(); Human woman = humanFactory.producWoman(); Human man = humanFactory.produceMan(); woman.say(); man.say(); &#125;&#125;//3. 结果输出i am woman !i am man! 静态工厂模式静态工厂方法模式，将上面的多个工厂方法模式里的方法置为静态的，不需要创建实例，直接调用即可(此代码略)。 总结总体来说，工厂模式适合：凡是出现了大量的产品需要创建，并且具有共同的接口时，可以通过工厂方法模式进行创建。在以上的三种模式中，第一种如果传入的字符串有误，不能正确创建对象，第三种相对于第二种，不需要实例化工厂类，所以，大多数情况下，我们会选用第三种——静态工厂方法模式。 抽象工厂模式（Abstract Factory）工厂方法模式有一个问题就是，类的创建依赖工厂类，也就是说，如果想要拓展程序，必须对工厂类进行修改，这违背了闭包原则，所以，从设计角度考虑，有一定的问题，如何解决？就用到抽象工厂模式，创建多个工厂类，这样一旦需要增加新的功能，直接增加新的工厂类就可以了，不需要修改之前的代码。 举例：上帝也发现了相同的问题，所以又进行优化。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110//1. 还是人类接口和两个男人、女人实现类/** * 工厂模式-人类接口 * @author HJK * @date 2020/1/6 16:38 */public interface Human &#123; /** * 定义人类会说话的方法 */ void say();&#125;/** * 人类接口具体实现类-男人 * @author HJK * @date 2020/1/6 19:57 */public class Man implements Human &#123; @Override public void say() &#123; System.out.println("i am man!"); &#125;&#125;/** * 人类接口具体实现类-女人 * @author HJK * @date 2020/1/6 19:57 */public class Woman implements Human &#123; @Override public void say() &#123; System.out.println("i am woman !"); &#125;&#125;//2. 使用相同的方法把工厂类进行优化/** * 设计一个工厂提供类接口 * @author HJK * @date 2020/1/6 20:38 */public interface FactoryProvider &#123; /** * 每个工厂都要有生产人类的方法 */ Human produce();&#125;/** * 生产女人的工厂 * @author HJK * @date 2020/1/6 20:38 */public class WomanFactory implements FactoryProvider&#123; @Override public Human produce() &#123; return new Woman(); &#125;&#125;/** * 生产男人的工厂 * @author HJK * @date 2020/1/6 20:40 */public class ManFactory implements FactoryProvider &#123; @Override public Human produce() &#123; return new Man(); &#125;&#125;//3. 编写测试类，进行结果测试。/** * 人类简单工厂模式测试 * @author HJK * @date 2020/1/6 20:05 */public class FactoryTest &#123; public static void main(String[] args) &#123; FactoryProvider provider1 = new WomanFactory(); FactoryProvider provider2 = new ManFactory(); Human woman = provider1.produce(); Human man = provider2.produce(); woman.say(); man.say(); &#125;&#125;//5. 结果输出i am woman !i am man! 通过以上代码可以看出，如果要创建一个不男不女，只要实现Human接口创建不男不女的实例，然后实现FactoryProvider接口实现不男不女的生产工厂，无需在现有代码基础上改动，扩展较好。 建造者模式建造者模式（BuilderPattern）又叫生成器模式，是一种对象构建模式。它可以将复杂对象的建造过程抽象出来（抽象类别），使这个抽象过程的不同实现方法可以构造出不同表现（属性）的对象。建造者模式是一步一步创建一个复杂的对象，它允许用户只通过指定复杂对象的类型和内容就可以构建它们，用户不需要知道内部的具体构建细节。具体类图如下： 举例：咱们来用建造者来演示一下美女换衣服吧。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150//1. 先创建一个女孩类，其中包含换衣服和换鞋子【提供产品的属性】import lombok.AllArgsConstructor;import lombok.Data;import lombok.NoArgsConstructor;import lombok.ToString;/** * * @author HJK * @date 2020/1/6 21:10 */@Data@NoArgsConstructor@AllArgsConstructor@ToStringpublic class Girl &#123; //衣服 private String dress; //鞋子 private String shoes;&#125;//2. 然后创建一个女孩建造者抽象类,用于不同女孩的继承。【定义产品需要的材料】/** * @author HJK * @date 2020/1/6 21:14 */public abstract class GirlBuilder &#123; Girl girl = new Girl(); /** * 换衣服 */ public abstract void buildDress(); /** * 换鞋子 */ public abstract void buildShoes(); /** * 换衣服鞋子完成，可以出去玩啦 * @return */ public Girl buildGirl()&#123; return girl; &#125;&#125;//3. 定义一个Director（指挥者）构建一个使用Builder接口的对象。// 它主要是用于创建一个复杂的对象。它主要有两个作用，一是：隔离了客户与对象的生产过程，// 二是：负责控制产品对象的生产过程。【提供构建产品的顺序(封装过程)】import lombok.AllArgsConstructor;import lombok.Setter;/** * @author HJK * @date 2020/1/6 21:16 */@AllArgsConstructorpublic class GirlDirector &#123; @Setter GirlBuilder girlBuilder; /** * 此方法用于规定建造的顺序，也就是说先换衣服还是先换鞋子 * @return */ public Girl girlConductor()&#123; //换衣服 girlBuilder.buildDress(); //换鞋子 girlBuilder.buildShoes(); //可以出门了 return girlBuilder.buildGirl(); &#125;&#125;//4. 定义具体的女孩建造类，ConcreteBuilder（具体建造者）：实现接口，构建和装配各个部件。【提供构建产品的具体材料】/** * 性感女孩的建造类 * @author HJK * @date 2020/1/6 21:20 */public class SexGirlBuilder extends GirlBuilder &#123; @Override public void buildDress() &#123; System.out.println("性感女孩喜欢穿露肩杉+超短裙~"); &#125; @Override public void buildShoes() &#123; System.out.println("性感女孩喜欢穿高跟鞋~"); &#125;&#125;/** * 学生女孩建造类 * @author HJK * @date 2020/1/6 21:23 */public class SchoolGirlBuilder extends GirlBuilder &#123; @Override public void buildDress() &#123; System.out.println("学生女孩必须穿校服"); &#125; @Override public void buildShoes() &#123; System.out.println("学生女孩必须穿平底鞋"); &#125;&#125;//5. 编写测试类，进行结果测试。/** * @author HJK * @date 2020/1/6 21:24 */public class BuilderTest &#123; public static void main(String[] args) &#123; //构建性感女孩建造类,填充具体信息 GirlBuilder girlBuilder = new SexGirlBuilder(); //构建指挥官进行顺序处理 GirlDirector girlDirector = new GirlDirector(girlBuilder); Girl girl1 = girlDirector.girlConductor(); &#125;&#125;//6. 结果输出性感女孩喜欢穿露肩杉+超短裙~性感女孩喜欢穿高跟鞋~ 原型模式（Prototype Pattern）原型模式虽然是创建型的模式，但是与工程模式没有关系，从名字即可看出，该模式的思想就是将一个对象作为原型，对其进行复制、克隆，产生一个和原对象类似的新对象。本小结会通过对象的复制，进行讲解。在Java中，复制对象是通过clone()实现的。具体类图如下： 举例：以Java中的Clone为例 12345678910111213/** * 定义原型类 * @author HJK * @date 2020/1/6 21:10 */public class Prototype implements Cloneable &#123; public Object clone() throws CloneNotSupportedException &#123; Prototype proto = (Prototype) super.clone(); return proto; &#125; &#125; 只需要实现Cloneable接口，覆写clone方法，此处clone方法可以改成任意的名称，因为Cloneable接口是个空接口，你可以任意定义实现类的方法名，如cloneA或者cloneB，因为此处的重点是super.clone()这句话，super.clone()调用的是Object的clone()方法，而在Object类中，clone()是native的，具体怎么实现，我会在另一篇文章中，关于解读Java中本地方法的调用，此处不再深究。在这儿，我将结合对象的浅复制和深复制来说一下，首先需要了解对象深、浅复制的概念： 浅复制：将一个对象复制后，基本数据类型的变量都会重新创建，而引用类型，指向的还是原对象所指向的。 深复制：将一个对象复制后，不论是基本数据类型还有引用类型，都是重新创建的。简单来说，就是深复制进行了完全彻底的复制，而浅复制不彻底。 结构型模式常用模式详解这些设计模式关注类和对象的组合。继承的概念被用来组合接口和定义组合对象获得新功能的方式。本章主要阐述适配器模式和代理模式。主要包括的各种模式的关系图如下： 适配器模式（Adapter Pattern）适配器模式是作为两个不兼容的接口之间的桥梁，目的是消除由于接口不匹配所造成的类的兼容性问题。主要分为三类：类的适配器模式、对象的适配器模式、接口的适配器模式。 类的适配器模式类的适配器是在适配类(Adaptee)拥有的方法基础上兼容目标接口(Target)中的方法。 1234567891011121314151617181920212223242526272829//目标接口interface Target&#123; public void request();&#125;//适配者接口class Adaptee&#123; public void specificRequest() &#123; System.out.println("适配者中的业务代码被调用！"); &#125;&#125;//类适配器类class ClassAdapter extends Adaptee implements Target&#123; public void request() &#123; specificRequest(); &#125;&#125;//客户端代码public class ClassAdapterTest&#123; public static void main(String[] args)&#123; Target target = new ClassAdapter(); target.request(); &#125;&#125; 对象的适配器模式基本思路和类的适配器模式相同，只是将Adapter类作修改，这次不继承Adaptee类，而是持有Adaptee类的实例，以达到解决兼容性的问题。 1234567891011121314151617181920212223//对象适配器类public class ObjectAdapter implements Target&#123; private Adaptee adaptee; public ObjectAdapter(Adaptee adaptee) &#123; this.adaptee=adaptee; &#125; public void request() &#123; adaptee.specificRequest(); &#125;&#125;//客户端代码public class ObjectAdapterTest&#123; public static void main(String[] args) &#123; Adaptee adaptee = new Adaptee(); Target target = new ObjectAdapter(adaptee); target.request(); &#125;&#125; 接口的适配器模式有时我们写的一个接口中有多个抽象方法，当我们写该接口的实现类时，必须实现该接口的所有方法，这明显有时比较浪费，因为并不是所有的方法都是我们需要的，有时只需要某一些，此处为了解决这个问题，我们引入了接口的适配器模式，借助于一个抽象类，该抽象类实现了该接口，实现了所有的方法，而我们不和原始的接口打交道，只和该抽象类取得联系，所以我们写一个类，继承该抽象类，重写我们需要的方法就行。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849/** * 总体接口 */public interface Sourceable&#123; void method1(); void method2();&#125;/** * 接口抽象类 */public abstract class Wrapper implements Sourceable&#123; public void method1()&#123;&#125; public void method2()&#123;&#125;&#125;/** * 具体实现类，仅实现需要的方法 */public class SourceSub1 extends Wrapper&#123; @Override public void method1() &#123; System.out.println("sub1_method1"); &#125;&#125;/** * 具体实现类，仅实现需要的方法 */public class SourceSub2 extends Wrapper&#123; @Override public void method2() &#123; System.out.println("sub2_method2"); &#125;&#125;/** * 测试类 */public class WrapperTest &#123; public static void main(String[] args) &#123; Sourceable s1 = new SourceSub1(); s1.method1(); s1.method2(); &#125;&#125; 装饰器模式（Decorator Pattern）顾名思义，装饰模式就是给一个对象增加一些新的功能，而且是动态的，要求装饰对象和被装饰对象实现同一个接口，装饰对象持有被装饰对象的实例。直接看代码: 12345678910111213141516171819202122232425262728293031323334353637383940414243444546 //Source类接口public interface Sourceable &#123; public void method(); &#125; //具体实现类public class Source implements Sourceable &#123; @Override public void method() &#123; System.out.println("the original method!"); &#125; &#125; //装饰类public class Decorator implements Sourceable &#123; private Sourceable source; public Decorator(Sourceable source)&#123; super(); this.source = source; &#125; @Override public void method() &#123; System.out.println("before decorator!"); source.method(); System.out.println("after decorator!"); &#125; &#125; //测试类public class DecoratorTest &#123; public static void main(String[] args) &#123; Sourceable source = new Source(); Sourceable obj = new Decorator(source); obj.method(); &#125; &#125; //测试结果before decorator!the original method!after decorator! 代理模式（Proxy Pattern）代理模式就是多一个代理类出来，替原对象进行一些操作，比如我们在租房子的时候回去找中介，为什么呢？因为你对该地区房屋的信息掌握的不够全面，希望找一个更熟悉的人去帮你做，此处的代理就是这个意思。代理模式也是框架设计最主要的模式之一。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253//抽象主题public interface Subject&#123; void Request();&#125;//真实主题public class RealSubject implements Subject&#123; public void Request() &#123; System.out.println("访问真实主题方法..."); &#125;&#125;//代理public class Proxy implements Subject&#123; private RealSubject realSubject; public void Request() &#123; if (realSubject == null) &#123; realSubject = new RealSubject(); &#125; preRequest(); realSubject.Request(); postRequest(); &#125; public void preRequest() &#123; System.out.println("访问真实主题之前的预处理。"); &#125; public void postRequest() &#123; System.out.println("访问真实主题之后的后续处理。"); &#125;&#125;//测试类public class ProxyTest&#123; public static void main(String[] args) &#123; Proxy proxy = new Proxy(); proxy.Request(); &#125;&#125;//测试结果访问真实主题之前的预处理。访问真实主题方法...访问真实主题之后的后续处理。 桥接模式（Bridge Pattern）桥接模式就是把事物和其具体实现分开，使他们可以各自独立的变化。桥接的用意是：将抽象化与实现化解耦，使得二者可以独立变化，像我们常用的JDBC桥DriverManager一样，JDBC进行连接数据库的时候，在各个数据库之间进行切换，基本不需要动太多的代码，甚至丝毫不用动，原因就是JDBC提供统一接口，每个数据库提供各自的实现，用一个叫做数据库驱动的程序来桥接就行了。 行为型模式常用模式详解行为型模式有11种，这些设计模式特别关注对象之间的通信，它们之间主要有以下区别。 模板模式（Template Pattern）定义一个操作中的算法骨架，而将算法的一些步骤延迟到子类中，使得子类可以不改变该算法结构的情况下重定义该算法的某些特定步骤。 1234567891011121314151617181920212223242526272829303132333435363738394041//1. 定义一个抽象计算类，包括一个抽象方法public abstract class AbstractCalculator &#123; //模板方法：定义了算法的骨架，按某种顺序调用其包含的基本方法。 public final int calculate(String exp,String opt)&#123; int array[] = split(exp,opt); return calculate(array[0],array[1]); &#125; //抽象方法：在抽象类中申明，由具体子类实现。 abstract public int calculate(int num1,int num2); //具体方法：在抽象类中已经实现，在具体子类中可以继承或重写它。 public int[] split(String exp,String opt)&#123; String array[] = exp.split(opt); int arrayInt[] = new int[2]; arrayInt[0] = Integer.parseInt(array[0]); arrayInt[1] = Integer.parseInt(array[1]); return arrayInt; &#125; &#125; //2. 定义具体计算类的子类public class Plus extends AbstractCalculator &#123; @Override public int calculate(int num1,int num2) &#123; return num1 + num2; &#125; &#125; //测试类public class StrategyTest &#123; public static void main(String[] args) &#123; String exp = "8+8"; AbstractCalculator cal = new Plus(); int result = cal.calculate(exp, "\\+"); System.out.println(result); &#125; &#125; 观察者模式（Observer Pattern）指多个对象间存在一对多的依赖关系，当一个对象的状态发生改变时，所有依赖于它的对象都得到通知并被自动更新。这种模式有时又称作发布-订阅模式、模型-视图模式。观察者模式很好理解，类似于邮件订阅和RSS订阅，当我们浏览一些博客或wiki时，经常会看到RSS图标，就这的意思是，当你订阅了该文章，如果后续有更新，会及时通知你。其实，简单来讲就一句话：当一个对象变化时，其它依赖该对象的对象都会收到通知，并且随着变化！对象之间是一种一对多的关系。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990//1. 定义观察者接口public interface Observer &#123; public void update(); &#125; //2. 定义两个观察者实现类public class Observer1 implements Observer &#123; @Override public void update() &#123; System.out.println("observer1 has received!"); &#125; &#125;public class Observer2 implements Observer &#123; @Override public void update() &#123; System.out.println("observer2 has received!"); &#125; &#125; //3. 定义订阅话题接口public interface Subject &#123; /*增加观察者*/ public void add(Observer observer); /*删除观察者*/ public void del(Observer observer); /*通知所有的观察者*/ public void notifyObservers(); /*自身的操作*/ public void operation(); &#125; //4. 定义话题接口实现类，用于维护多个话题需要public abstract class AbstractSubject implements Subject &#123; private Vector&lt;Observer&gt; vector = new Vector&lt;Observer&gt;(); @Override public void add(Observer observer) &#123; vector.add(observer); &#125; @Override public void del(Observer observer) &#123; vector.remove(observer); &#125; @Override public void notifyObservers() &#123; Enumeration&lt;Observer&gt; enumo = vector.elements(); while(enumo.hasMoreElements())&#123; enumo.nextElement().update(); &#125; &#125; &#125; //5.定义具体话题实现类public class MySubject extends AbstractSubject &#123; @Override public void operation() &#123; System.out.println("update self!"); notifyObservers(); &#125; &#125; //6. 测试public class ObserverTest &#123; public static void main(String[] args) &#123; Subject sub = new MySubject(); //添加观察者监听对象 sub.add(new Observer1()); sub.add(new Observer2()); //进行更新通知 sub.operation(); &#125; &#125; //7. 测试结果update self!observer1 has received!observer2 has received! 状态模式（State Pattern）对有状态的对象，把复杂的“判断逻辑”提取到不同的状态对象中，允许状态对象在其内部状态发生改变时改变其行为。核心思想就是：当对象的状态改变时，同时改变其行为，很好理解！就拿QQ来说，有几种状态，在线、隐身、忙碌等，每个状态对应不同的操作，而且你的好友也能看到你的状态，所以，状态模式就两点：1、可以通过改变状态来获得不同的行为。2、你的好友能同时看到你的变化。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667//环境类public class Context&#123; private State state; //定义环境类的初始状态 public Context() &#123; this.state=new ConcreteStateA(); &#125; //设置新状态 public void setState(State state) &#123; this.state=state; &#125; //读取状态 public State getState() &#123; return(state); &#125; //对请求做处理 public void Handle() &#123; state.Handle(this); &#125;&#125;//抽象状态类public abstract class State&#123; public abstract void Handle(Context context);&#125;//具体状态A类public class ConcreteStateA extends State&#123; public void Handle(Context context) &#123; System.out.println("当前状态是 A."); context.setState(new ConcreteStateB()); &#125;&#125;//具体状态B类public class ConcreteStateB extends State&#123; public void Handle(Context context) &#123; System.out.println("当前状态是 B."); context.setState(new ConcreteStateA()); &#125;&#125;//测试类public class StatePatternClient&#123; public static void main(String[] args) &#123; Context context=new Context(); //创建环境 context.Handle(); //处理请求 context.Handle(); context.Handle(); context.Handle(); &#125;&#125;//测试结果当前状态是 A.当前状态是 B.当前状态是 A.当前状态是 B. 中介者模式（Mediator Pattern）定义一个中介对象来封装一系列对象之间的交互，使原有对象之间的耦合松散，且可以独立地改变它们之间的交互。中介者模式又叫调停模式，它是迪米特法则的典型应用。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091929394//抽象中介者public abstract class Mediator&#123; public abstract void register(Colleague colleague); public abstract void relay(Colleague cl); //转发&#125;//具体中介者public class ConcreteMediator extends Mediator&#123; private List&lt;Colleague&gt; colleagues=new ArrayList&lt;Colleague&gt;(); public void register(Colleague colleague) &#123; if(!colleagues.contains(colleague)) &#123; colleagues.add(colleague); colleague.setMedium(this); &#125; &#125; public void relay(Colleague cl) &#123; for(Colleague ob:colleagues) &#123; if(!ob.equals(cl)) &#123; ((Colleague)ob).receive(); &#125; &#125; &#125;&#125;//抽象同事类public abstract class Colleague&#123; protected Mediator mediator; public void setMedium(Mediator mediator) &#123; this.mediator=mediator; &#125; public abstract void receive(); public abstract void send();&#125;//具体同事类public class ConcreteColleague1 extends Colleague&#123; public void receive() &#123; System.out.println("具体同事类1收到请求。"); &#125; public void send() &#123; System.out.println("具体同事类1发出请求。"); mediator.relay(this); //请中介者转发 &#125;&#125;//具体同事类public class ConcreteColleague2 extends Colleague&#123; public void receive() &#123; System.out.println("具体同事类2收到请求。"); &#125; public void send() &#123; System.out.println("具体同事类2发出请求。"); mediator.relay(this); //请中介者转发 &#125;&#125;//测试类public class MediatorPattern&#123; public static void main(String[] args) &#123; Mediator md=new ConcreteMediator(); Colleague c1,c2; c1=new ConcreteColleague1(); c2=new ConcreteColleague2(); md.register(c1); md.register(c2); c1.send(); System.out.println("-------------"); c2.send(); &#125;&#125;//测试结果具体同事类1发出请求。具体同事类2收到请求。-------------具体同事类2发出请求。具体同事类1收到请求。 总结以上举例阐述了常用的设计模式和具体实现。其他模式的实现有机会再补充。充分理解各大设计模式对于阅读源码及程序设计方面会有较大帮助。推荐以下设计模式文章的链接，本文也参考了以下的文章： Java开发中的23种设计模式详解(转)www.cnblogs.com/maowang1991/archive/2013/04/15/3023236.html 软件设计模式概述c.biancheng.net/view/1317.html 设计模式简介www.runoob.com/design-pattern/design-pattern-intro.html]]></content>
      <categories>
        <category>Java基础</category>
      </categories>
      <tags>
        <tag>Java基础</tag>
        <tag>设计模式</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java基础知识回顾总结[总篇]]]></title>
    <url>%2Fblog%2F20200105-Java%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86%E5%9B%9E%E9%A1%BE%E6%80%BB%E7%BB%93-%E6%80%BB%E7%AF%87%2F</url>
    <content type="text"><![CDATA[最近在对Java基础知识进行回顾及总结，个人认为不应该直接去研究具体技术如何实现，源码剖析或者原理探究。而是应使用自上而下的方式去看待整体基础知识体系。换句话说打通这些知识才可以真正入门Java。接下来我们就进行具体阐述… 如果你打算入门Java却不知道如何入手，或者你向我一样想回顾基础知识，温故而知新。那么我们就一起来看看基础方面需要搞定哪些东西吧。 文章上方的图是以我个人的视角，从上至下的方式进行全局视角的归纳，我以为Java入门必须要了解的一些东西(可能会有缺失)。那么在阐述图中的各种分类之前我们应该先定义基础知识的范围，简单的来说若你可以学以致用这些知识，可以在遇到其他技术时可以比较轻松的学习，其实就是以不变应万变。废话不多说，我们就自下而上去逐级阐述各个技术栈吧。 面向对象一切皆对象我相信大家对于这句话一定不陌生，因为这世上的一切都可以抽象成一个对象，比如程序员爱开的玩笑，没有女朋友？new 一个啊，于是乎就有了类似以下的代码: 123456789101112131415161718192021222324252627282930313233343536373839404142package indi.hjk.studydemo;import lombok.AllArgsConstructor;import lombok.Data;import lombok.NoArgsConstructor;import java.util.List;/** * 面向对象-女朋友测试类 * @author HJK * @date 2020/1/5 17:04 */public class TestCreateGirlFriend &#123; public static void main(String[] args) &#123; //实例化一个女朋友,颜值很高,还是短发 GirlFriend girlFirend1 = new GirlFriend(9.98,1); //实例化另一个女朋友，颜值顶天，可惜没头发 GirlFriend girlFirend2 = new GirlFriend(9.99,2); //然后故事你们继续... &#125;&#125;/** * 抽象一个女朋友对象 * 假设两个属性 */@Data@NoArgsConstructor@AllArgsConstructorclass GirlFriend&#123; //颜值 0-10 private Double faceScore; //发型 0长发 1短发 2没有头发... private Integer hairStyle;&#125; 上面开个玩笑，面向对象这块为什么放在最下面呢，因为这个是编程最为基础的东西，当让还有面向过程(这里我们不讨论)。面向对象为什么重要，以我的观点来看是因为它主要给你提供的是思维方式，计算机是呆板的，只会执行二进制，并不会理解你丰富的想象力，你要告诉计算机干什么。所以你必须要把你的想象力转为可以执行的机器码，那么怎么转变呢？那就使用面向对象的思维方式。 想要理解面向对象，不得不说的就是面向对象的三个特性:继承、封装、多态，这是最为本质的东西。其次还有设计模式六大原则: 开闭原则（Open Close Principle） 里氏代换原则（Liskov Substitution Principle） 依赖倒转原则（Dependence Inversion Principle） 接口隔离原则（Interface Segregation Principle） 迪米特法则（最少知道原则）（Demeter Principle） 合成复用原则（Composite Reuse Principle） 除此之外，23中设计模式是经过多少程序员积累的结晶，这些东西会帮助你在未来的设计程序、阅读程序中助力，让你感觉事半功倍。之后我会更新一些文章独立说明每一块技术栈，这里就不过多阐述。 编码规范为什么我会把编码规范放在最底层，因为代码的编写风格会一直跟随着你，我见过很多优秀的程序员，可以写出很棒的函数，但是代码可读性真的很差。并不是说要求你的代码可以让菜鸟读懂，而是说该注释的核心函数、函数用途、变量范围等要注释，该缩进的缩进… 代码不仅仅是给机器运行的，也是给别人看的。现实生产环境中，我们都是一个团队在开发，如果你的代码不按照规范那么可维护性很低，很容易造成生产事故。所以好的编码习惯会让你少加班。 数据结构程序就是数据结构加算法 这句话上大学那会就一直被老师念叨。其实做几年程序员你会发现，说的真是这样，那些没认真听老师念叨的如今都后悔了。大概说说数据结构，对于基础这块，主要包括数组、链表,队列、栈、散列表(哈希表)、树、堆等结构，当然这都是大家知道的，但是如果要脱颖而出，不仅仅要知道结构是如何，如何使用，时间复杂度和空间复杂度等，还要知道什么情况下用什么样的数据结构是最优的，java是如何实现的这些结构，又是怎么用的，就是一步步向下挖，挖到什么程度呢？吊打面试官吧。这些都是最为本质的东西，必须要掌握。 算法算法是什么？我觉得就是解决问题的方式。数据结构解决了如何存储数据的问题，而算法就是你要用什么方式去解决这个问题。就拿银行柜台取钱的例子，原本柜台只有一个窗口，每天排满了长队，你只能通过这个窗口一个一个排队处理业务。这个问题抽象成程序就是有一个队列（FIFO）用来排队，有一个业务类的处理方法，每次从队列顶部拉出来一个人，调用业务处理类给他办业务。但是这时候如果我们打算更高效的处理业务怎么办呢？一个简单的方法就是增加一个业务窗口(多线程)，然后就是两个队列进行处理。对于基础知识来说，还是要掌握如排序算法、查找算法、匹配算法及其他经典算法。此外要关注算法间的选型，那种算法时间复杂度更优，哪种算法空间复杂度更优，哪种算法适用于什么样的场景等等。 网络基础为什么网络基础这么重要呢？大部分Java程序员最后还是发展在Web方面，这也因为Java适用场景的独特性,知道网络的原理对网络优化、问题解决方面有优势。所以，基础方面一定要搞懂如HTTP1.0/2.0、ISO七层模型、TCP/UDP、Socket、WebSocket、HTTPS,有能力还要研究XMPP、MQTT等即时通讯协议。这里所说的搞懂，至少要能知道这些问题，如HTTP三次握手四次挥手到底是啥？HTTP1.0和2.0有啥不同?UDP为什么是不可靠的？ 数据存储数据存储主要是在数据库、持久化等方面，数据最终是要持久化到磁盘的。基础方面需要了解一些磁盘读取原理、文件读写、关系型数据库及相关设计和规范、SQL优化等，最好还可以了解一些非关系型数据库，如Redis、MongoDB、TiDB等，还可以了解一些搜索引擎如ElasticSearch、Solr的使用和原理。 工具工欲善其事必先利其器 工具是高效完成工作的前提，身为程序员，工具不仅仅包括IDE、各种组件、各种软件…你还要有一台高性能(i7\16G+RAM\1TSSD…)电脑、机械键盘、降噪耳机…哦，还需要一台自行车。 JDK请不要闲的没事先去研究什么开源框架，先把JDK研究透了再说。首先对JDK需要一个源码级的Review，窥探源码中如何使用各种设计模式各种原理、还需要深入理解JVM，以及JDK各个版本的优化措施等。这一趟搞下来，遇到面试官问你JDK，直接吊打。不然人家问你啥叫代码逃逸？啥叫指令重排？JDK哪里使用了CAS和AQS？…好，回家等通知。 测试你知道90%（这个结果是我个人经过实际累加求平均获得）的程序员不会进行单元测试吗？真实案例，基本上程序员的测试就是跑一遍，没问题就提交代码了。所以说我这BUG还没写完就上线了… 我个人认为，QA人员并不是最好的测试，而是你程序员自己。只有程序员知道自己在写什么，若站在项目管理角度，一定要程序员编写单元测试。此外个人的修养也很关键，你只有培养自己测试的习惯，丰富自己测试的知识，才会知道自己程序的薄弱点。总的来说，等你被罚钱你就知道测试的重要性了。 JavaWeb &amp; Android到此，你的Java基础已经较为牢靠了。现在开始变现了(咳咳咳)。要说Java变现的方式很多，你可以搞Web,也可以搞Android,你要是想搞桌面应用，对不起，出门左转。开个玩笑，JavaWeb是比较主流的，若要参与Web后台开发，必须要补充前端知识，以及开源框架等。最为基础的如SSM，Web容器如Tomcat等。进阶可以玩一玩分布式、微服务。闲的没事可以研究大数据和AI。Android也可以玩一玩，不是很复杂,只要你稍微了解一下四大组件、Activity生命周期就可以写APP了。我还是以Web为主，对于基础知识，只要搞定前端(HTML\CSS\JS\JQUERY…)、后端(Servlet\SSM等开源框架)源码级理解、Web容器(Tomcat\Jetty…)使用及调优、中间件(MQ\Cache\RPC…)使用原理窥探、负载(Nginx\LVS)…打住，越说越多了。 阅读一定要保持阅读的习惯。其实应该说是学习的习惯，可能对于新手一两年你们没有差距，但是只要保持学习的态度，用不了多久你就会超越对方。阅读不能没有计划和目标，要有目标的学习，并且把大目标拆分为小目标(WBS)，善于梳理脉络。除了技术书籍之外我非常建议阅读如人性、心理学、理论著作、传记及散文。如有资料需要可以关注我的公众号，将不定期分享。 总结咳咳咳，你能阅读到这里，你已经超过了50%的人。上面都是我瞎扯的，下面开始说干货。对于基础知识来说，我整理了一个图，覆盖了大部分基础知识。后期我会按照这个图进行一些技术文章分享。 并不是说你都有涉猎就很牛B了，这仅仅是个开始。我们尽可能成为T型人才，涉猎广，但是在某些领域是专家级别，这样才能立于不败之地。深度很关键，你会这些，别人也会这些。但是比如你知道为什么JVM没有按照你的代码顺序进行执行(多线程中JVM会自动进行指令重排优化),那你就超越了很多人。 OK，今天就扯到这里，老妈叫我吃饭了，感兴趣请关注我的公众号。]]></content>
      <categories>
        <category>Java基础</category>
      </categories>
      <tags>
        <tag>Java基础</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[新的开始]]></title>
    <url>%2Fblog%2F20200104-%E6%96%B0%E7%9A%84%E5%BC%80%E5%A7%8B%2F</url>
    <content type="text"><![CDATA[我们都是程序员，而程序员的心中都驻着个建筑师，当他们到达一个地方的时候，他们想做的第一件事就是把这个地方夷为平地，然后在上面建造一些宏伟的建筑。我们对那些渐进式的更新不感兴趣：如小修小补、改进、种种花草等等。- Joel Spolsky，Stackoverflow公司CEO 2020年已至，转眼置身编程事业已4年有余。反思四年走过的路，有收获也有不足。总结起来，认为自己可以做的更好，不应该局限于此。如今年岁上涨，发现距离自己的目标仍旧遥远，总在原地踏步，成长太慢。新的一年，给自己重新定位，向着自己的目标前行！ 新的一年，重新定位自己，努力向架构师方向发展。 概要计划: Java基础知识回顾与总结; JVM理解优化、Java多线程及IO回顾总结; 加强书籍结构及算法的理解实践; 开源框架的使用理解实践等; 微服务架构理解与实践; ServiceMesh理解与实践; 大数据开源方案深入[置后]; 人工智能方向研究[置后]; 阅读书籍、提升格局; 持续更新博客; 虽然计划如此，但是我并不知道我能否按计划执行，因为未来的事情谁也说不准。尽量坚持把，如果没有目标，人就会迷茫。 致读者:若有幸在此遇见你，真是三生有幸！我想留下一些什么，即使并没有人关注。如果你喜欢我写的东西，那真心的谢谢你。如果我的某些言论让你感到愤怒或悲伤，也请谅解。最后感谢您的倾心阅读。]]></content>
      <categories>
        <category>随笔</category>
      </categories>
      <tags>
        <tag>随笔</tag>
      </tags>
  </entry>
</search>
