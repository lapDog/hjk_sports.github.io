---
title: Java 23种设计模式
date: 2020-01-05 20:32:22
updated: 2020-01-05 20:32:22
tags: 
  - Java基础
  - 设计模式
categories: Java基础
---

设计模式（Design pattern）代表了最佳的实践，通常被有经验的面向对象的软件开发人员所采用。设计模式是软件开发人员在软件开发过程中面临的一般问题的解决方案。这些解决方案是众多软件开发人员经过相当长的一段时间的试验和错误总结出来的。

设计模式是一套被反复使用的、多数人知晓的、经过分类编目的、代码设计经验的总结。使用设计模式是为了重用代码、让代码更容易被他人理解、保证代码可靠性。 毫无疑问，设计模式于己于他人于系统都是多赢的，设计模式使代码编制真正工程化，设计模式是软件工程的基石，如同大厦的一块块砖石一样。项目中合理地运用设计模式可以完美地解决很多问题，每种模式在现实中都有相应的原理来与之对应，每种模式都描述了一个在我们周围不断重复发生的问题，以及该问题的核心解决方案，这也是设计模式能被广泛应用的原因。

以上都是一些类似官方的定义，概念的东西就不多说了，若想系统了解可以百度。在讨论设计模式之前，我们先看看设计模式的六大原则:

1. 开闭原则（Open Close Principle）
开闭原则的意思是,对扩展开放，对修改关闭。在程序需要进行拓展的时候，不能去修改原有的代码，实现一个热插拔的效果。简言之，是为了使程序的扩展性好，易于维护和升级。想要达到这样的效果，我们需要使用接口和抽象类，后面的具体设计中我们会提到这点。

2. 里氏代换原则（Liskov Substitution Principle）
里氏代换原则是面向对象设计的基本原则之一。 里氏代换原则中说，任何基类可以出现的地方，子类一定可以出现。LSP 是继承复用的基石，只有当派生类可以替换掉基类，且软件单位的功能不受到影响时，基类才能真正被复用，而派生类也能够在基类的基础上增加新的行为。里氏代换原则是对开闭原则的补充。实现开闭原则的关键步骤就是抽象化，而基类与子类的继承关系就是抽象化的具体实现，所以里氏代换原则是对实现抽象化的具体步骤的规范。

3. 依赖倒转原则（Dependence Inversion Principle）
这个原则是开闭原则的基础，具体内容：针对接口编程，依赖于抽象而不依赖于具体。

4. 接口隔离原则（Interface Segregation Principle）
这个原则的意思是,使用多个隔离的接口，比使用单个接口要好。它还有另外一个意思是：降低类之间的耦合度。由此可见，其实设计模式就是从大型软件架构出发、便于升级和维护的软件设计思想，它强调降低依赖，降低耦合。

5. 迪米特法则，又称最少知道原则（Demeter Principle）
最少知道原则是指：一个实体应当尽量少地与其他实体之间发生相互作用，使得系统功能模块相对独立。

6. 合成复用原则（Composite Reuse Principle）
合成复用原则是指：尽量使用合成/聚合的方式，而不是使用继承。

设计模式都是严格或尽可能的按照这六大原则进行设计，当然我们实际工作种可能进行妥协而不会严格遵守，但是这些原则就像是一个尺标。接下来我们从整体去看设计模式之间的区别和联系并进行分类，具体如下：

# 设计模式分类

23种设计模式可以总体可以分为三种: `创建型模式（Creational Patterns）`、`结构型模式（Structural Patterns）`、`行为型模式（Behavioral Patterns）`。
具体包含模式如下:

| 模式&描述 | 包含模式 |
| :---- | :----: |
|  **创建型模式(5种)** <br/> 这些设计模式提供了一种在创建对象的同时隐藏创建逻辑的方式，而不是使用 new 运算符直接实例化对象。这使得程序在判断针对某个给定实例需要创建哪些对象时更加灵活。 | 单例模式（Singleton Pattern）<br/> 工厂模式（Factory Pattern）<br/> 抽象工厂模式（Abstract Factory Pattern）<br/> 建造者模式（Builder Pattern）<br/> 原型模式（Prototype Pattern） |
| **结构型模式(7种)** <br/> 这些设计模式关注类和对象的组合。继承的概念被用来组合接口和定义组合对象获得新功能的方式。 | 适配器模式（Adapter Pattern）<br/> 装饰器模式（Decorator Pattern）<br/> 代理模式（Proxy Pattern）<br/>  外观模式（Facade Pattern）<br/> 桥接模式（Bridge Pattern）<br/> 组合模式（Composite Pattern）<br/> 享元模式（Flyweight Pattern）  |
| **行为型模式(11种)** <br/> 这些设计模式特别关注对象之间的通信。 | 策略模式（Strategy Pattern）<br/> 模板模式（Template Pattern）<br/> 观察者模式（Observer Pattern）<br/>  责任链模式（Chain of Responsibility Pattern） <br/> 命令模式（Command Pattern）<br/> 解释器模式（Interpreter Pattern） <br/> 迭代器模式（Iterator Pattern）<br/> 中介者模式（Mediator Pattern）<br/> 备忘录模式（Memento Pattern）<br/> 状态模式（State Pattern）<br/>  访问者模式（Visitor Pattern）|

各种设计模式之间的联系如下：

{% img /static/imgs/23种设计模式联系图.jpg 23种设计模式联系图 %}

当然并不只有这23种设计模式，实际工作中也不并不是每一种设计模式都有用到。接下来，我将举例一些常用的设计模式并用源码的方式来说明这些模式的原理、实现及适用场景。

# 创建型模式常用模式详解

创建型模式中的各种模式真的非常常见，我们将一个个进行详细阐述。

## 单例模式（Singleton Pattern）

`“保证一个类仅有一个实例，并提供一个访问它的全局访问点。” ——《设计模式》(艾迪生维斯理, 1994)` 单例就是整个程序有且仅有一个实例。该类负责创建自己的对象，同时确保只有一个对象被创建。在Java，一般常用在工具类的实现或创建对象需要消耗资源。

### 单例模式优点

1. 保证全局只有一个实例，可以一定程度保证实例的资源调用(受控访问)。
2. 在内存里只有一个实例，减少了内存的开销，尤其是频繁的创建和销毁实例。
3. 因为由类自己来控制实例化进程，类就在改变实例化进程上有相应的伸缩性。

### 单例模式缺点

1. 与单一职责冲突。
2. 扩展性差，无法继承。

### 单例模式实现条件

1. 私有的构造器。
2. 对外提供获取实例的静态方法。
3. 在内部产生本类的私有实例化对象。

### 单例模式的各种实现

#### 懒汉模式

可以满足基本要求，延迟初始化，但是线程不安全。

```java
package indi.hjk.studydemo.Singleton;

/**
 * 单例模式-简单单例实现
 * @author HJK
 * @date 2020/1/6 16:21
 */
public class Singleton {

    //持有私有静态实例，防止被引用，此处赋值为null，目的是实现延迟加载(懒汉)
    private static Singleton instance = null;

    //私有构造方法，防止被实例化
    private Singleton() {
    }

    //静态工程方法，创建实例
    public static Singleton getInstance(){
        if(instance == null){
            instance = new Singleton();
        }
        return instance;
    }

    //如果该对象被用于序列化，可以保证对象在序列化前后保持一致
    public Object readResolve(){
        return instance;
    }
}

```

#### 饿汉模式

线程安全，比较常用，但容易产生垃圾，因为一开始就初始化。

```java 
public class Singleton {  

    //直接初始化实例
    private static Singleton instance = new Singleton();  

    private Singleton (){
    }  

    public static Singleton getInstance() {  
        return instance;  
    }  
}
```

#### 双重锁模式(Double Check Lock)

线程安全，延迟初始化。这种方式采用双锁机制，安全且在多线程情况下能保持高性能。

```java 
public class Singleton {  
    
    //使用volatile保证线程可见性、防止JVM指令重排
    private volatile static Singleton singleton;  
    
    private Singleton (){
    }  
    
    public static Singleton getSingleton() {  
        //第一次检查防止重新进入创建实例加锁，一定程度保证了性能
        if (singleton == null) {  
            synchronized (Singleton.class) {  
                //进行同步，避免多线程问题
                if (singleton == null) {  
                    singleton = new Singleton();  
                }  
            }  
        }  
        return singleton;  
    }  
}
```

#### 静态内部类模式

线程安全，只有一个线程可以获得对象的初始化锁，其他线程无法进行初始化，保证对象的唯一性。

```java 
public class Singleton { 

    private Singleton(){
    }

    public static Singleton getInstance(){  
        return Inner.instance;  
    }  
    
    //静态内部类，保证实例唯一性
    private static class Inner {  
        private static final Singleton instance = new Singleton();  
    }  
} 
```

#### 枚举类模式

它不仅能避免多线程同步问题，而且还自动支持序列化机制，防止反序列化重新创建新的对象，绝对防止多次实例化。

```java 
public class User {
    //私有化构造函数
    private User(){ }
 
    //定义一个静态枚举类
    static enum SingletonEnum{
        //创建一个枚举对象，该对象天生为单例
        INSTANCE;
        private User user;
        //私有化枚举的构造函数
        private SingletonEnum(){
            user=new User();
        }
        public User getInstnce(){
            return user;
        }
    }
 
    //对外暴露一个获取User对象的静态方法
    public static User getInstance(){
        return SingletonEnum.INSTANCE.getInstnce();
    }
}
```

#### 使用单例模式的源码剖析

使用单例模式情况较为广泛，举例JDK源码中，如`Runtime`类可以获得应用运行时的一些状态（主要包括使用的内存和cpu个数）和在应用运行时执行一些操作，此类就使用了单例模式。

```java 
package java.lang;

/**
 * Every Java application has a single instance of class
 * <code>Runtime</code> that allows the application to interface with
 * the environment in which the application is running. The current
 * runtime can be obtained from the <code>getRuntime</code> method.
 * <p>
 * An application cannot create its own instance of this class.
 *
 * @author  unascribed
 * @see     java.lang.Runtime#getRuntime()
 * @since   JDK1.0
 */

public class Runtime {
    private static Runtime currentRuntime = new Runtime();

    /**
     * Returns the runtime object associated with the current Java application.
     * Most of the methods of class <code>Runtime</code> are instance
     * methods and must be invoked with respect to the current runtime object.
     *
     * @return  the <code>Runtime</code> object associated with the current
     *          Java application.
     */
    public static Runtime getRuntime() {
        return currentRuntime;
    }

    /** Don't let anyone else instantiate this class */
    private Runtime() {}
    
    //以下代码省略...
}
```

#### 单例模式总结

总体来说，单例模式在实际工作中可以说是最为常用的设计模式之一了。主要用于需要实例唯一的情况使用，以上总结了常见的单例模式实现方式。此外还需要注意一些问题:

1. "单元素的枚举类型已经成为实现Singleton的最佳方法。" -- 出自 《effective java》 实际使用中，枚举可能导致代码阅读性较差，可选择静态内部类模式。
2. "任何一个readObject方法，不管是显式的还是默认的，它都会返回一个新建的实例，这个新建的实例不同于该类初始化时创建的实例。" 如果单例实例需要序列化支持，需要重写`readResolve`方法（枚举除外）。


## 工厂模式（Factory Pattern）

工厂模式分为简单工厂模式，工厂方法模式和抽象工厂模式，它们都属于设计模式中的创建型模式。我们在创建对象时不会对客户端直接暴露创建逻辑，而是通过使用一个共同的接口根据不同的条件来指向具体想要创建的对象。其主要功能都是帮助我们把对象的实例化部分抽取了出来，目的是降低系统中代码耦合度，并且增强了系统的扩展性。

### 简单工厂模式

简单工厂模式最大的优点在于实现对象的创建和对象的使用分离，将对象的创建交给专门的工厂类负责，但是其最大的缺点在于工厂类不够灵活，增加新的具体产品需要修改工厂类的判断逻辑代码，而且产品较多时，工厂方法代码逻辑将会非常复杂。

举例：我们来模拟上帝造人的例子吧。

```java 

// 1. 先定义一个人类接口

/**
 * 工厂模式-人类接口
 * @author HJK
 * @date 2020/1/6 16:38
 */
public interface Human {

    /**
     * 定义人类会说话的方法
     */
    void say();
}


//2. 对人类接口具体实现两个类，男人和女人。

/**
 * 人类接口具体实现类-男人
 * @author HJK
 * @date 2020/1/6 19:57
 */
public class Man implements Human {

    @Override
    public void say() {
        System.out.println("i am man!");
    }
}

/**
 * 人类接口具体实现类-女人
 * @author HJK
 * @date 2020/1/6 19:57
 */
public class Woman implements Human {

    @Override
    public void say() {
        System.out.println("i am woman !");
    }
}

//3. 定义人类生产工厂，用于生产各种人。

/**
 * 人类生产工厂类
 * @author HJK
 * @date 2020/1/6 19:59
 */
public class HumanFactory {

    /**
     * 人类生产方法，只要传入指定类型我就可以造人哦！
     * @param type 0女人 1男人
     * @return 返回人类具体实现
     */
    public Human produce(Integer type){
        if(type == 0){
            return new Woman();
        }else if(type == 1){
            return  new Man();
        }else{
            System.out.println("不合法的参数类型");
            return null;
        }
    }
}


//4. 编写测试类，进行结果测试。

/**
 * 人类简单工厂模式测试
 * @author HJK
 * @date 2020/1/6 20:05
 */
public class FactoryTest {

    public static void main(String[] args) {

        HumanFactory humanSimpleFactory = new HumanFactory();

        Human woman = humanSimpleFactory.produce(0);
        Human man = humanSimpleFactory.produce(1);

        woman.say();
        man.say();

    }
}

//5. 结果输出

i am woman !
i am man!

```

### 多工厂模式

多个工厂方法模式，是对普通工厂方法模式的改进，在普通工厂方法模式中，如果传递的字符串出错，则不能正确创建对象，而多个工厂方法模式是提供多个工厂方法，分别创建对象。

举例：上帝发现了上面的问题，进行了优化。

```java 

//1.上帝将男人女人生产方法进行拆分，并标记原有的生产方法过时

/**
 * 人类生产工厂类
 * @author HJK
 * @date 2020/1/6 19:59
 */
public class HumanFactory {

    /**
     * 人类生产方法，只要传入指定类型我就可以造人哦！
     * @param type 0女人 1男人
     * @return 返回人类具体实现
     */
    @Deprecated
    public Human produce(Integer type){
        if(type == 0){
            return new Woman();
        }else if(type == 1){
            return  new Man();
        }else{
            System.out.println("不合法的参数类型");
            return null;
        }
    }

    /**
     * 生产男人的工厂方法
     * @return
     */
    public Human producWoman(){
        return new Woman();
    }

    /**
     * 生产女人的工厂方法
     * @return
     */
    public Human produceMan(){
        return new Man();
    }
}

//2. 编写测试类，进行结果测试。

/**
 * 人类简单工厂模式测试
 * @author HJK
 * @date 2020/1/6 20:05
 */
public class FactoryTest {

    public static void main(String[] args) {

        HumanFactory humanSimpleFactory = new HumanFactory();

        Human woman = humanFactory.producWoman();
        Human man = humanFactory.produceMan();

        woman.say();
        man.say();

    }
}

//3. 结果输出

i am woman !
i am man!

```

### 静态工厂模式

静态工厂方法模式，将上面的多个工厂方法模式里的方法置为静态的，不需要创建实例，直接调用即可(此代码略)。

### 总结

总体来说，工厂模式适合：凡是出现了大量的产品需要创建，并且具有共同的接口时，可以通过工厂方法模式进行创建。在以上的三种模式中，第一种如果传入的字符串有误，不能正确创建对象，第三种相对于第二种，不需要实例化工厂类，所以，大多数情况下，我们会选用第三种——静态工厂方法模式。

## 抽象工厂模式（Abstract Factory）

工厂方法模式有一个问题就是，类的创建依赖工厂类，也就是说，如果想要拓展程序，必须对工厂类进行修改，这违背了闭包原则，所以，从设计角度考虑，有一定的问题，如何解决？就用到抽象工厂模式，创建多个工厂类，这样一旦需要增加新的功能，直接增加新的工厂类就可以了，不需要修改之前的代码。

举例：上帝也发现了相同的问题，所以又进行优化。

```java 

//1. 还是人类接口和两个男人、女人实现类

/**
 * 工厂模式-人类接口
 * @author HJK
 * @date 2020/1/6 16:38
 */
public interface Human {

    /**
     * 定义人类会说话的方法
     */
    void say();
}

/**
 * 人类接口具体实现类-男人
 * @author HJK
 * @date 2020/1/6 19:57
 */
public class Man implements Human {

    @Override
    public void say() {
        System.out.println("i am man!");
    }
}

/**
 * 人类接口具体实现类-女人
 * @author HJK
 * @date 2020/1/6 19:57
 */
public class Woman implements Human {

    @Override
    public void say() {
        System.out.println("i am woman !");
    }
}

//2. 使用相同的方法把工厂类进行优化

/**
 * 设计一个工厂提供类接口
 * @author HJK
 * @date 2020/1/6 20:38
 */
public interface FactoryProvider {

    /**
     * 每个工厂都要有生产人类的方法
     */
    Human produce();
}

/**
 * 生产女人的工厂
 * @author HJK
 * @date 2020/1/6 20:38
 */
public class WomanFactory implements FactoryProvider{

    @Override
    public Human produce() {
        return new Woman();
    }
}

/**
 * 生产男人的工厂
 * @author HJK
 * @date 2020/1/6 20:40
 */
public class ManFactory implements FactoryProvider {

    @Override
    public Human produce() {
        return new Man();
    }
}

//3. 编写测试类，进行结果测试。

/**
 * 人类简单工厂模式测试
 * @author HJK
 * @date 2020/1/6 20:05
 */
public class FactoryTest {

    public static void main(String[] args) {

         FactoryProvider provider1 = new WomanFactory();
         FactoryProvider provider2 = new ManFactory();

         Human woman = provider1.produce();
         Human man = provider2.produce();

         woman.say();
         man.say();

    }
}

//5. 结果输出

i am woman !
i am man!

```

通过以上代码可以看出，如果要创建一个不男不女，只要实现`Human`接口创建不男不女的实例，然后实现`FactoryProvider`接口实现不男不女的生产工厂，无需在现有代码基础上改动，扩展较好。


## 建造者模式

建造者模式（BuilderPattern）又叫生成器模式，是一种对象构建模式。它可以将复杂对象的建造过程抽象出来（抽象类别），使这个抽象过程的不同实现方法可以构造出不同表现（属性）的对象。建造者模式是一步一步创建一个复杂的对象，它允许用户只通过指定复杂对象的类型和内容就可以构建它们，用户不需要知道内部的具体构建细节。
具体类图如下：

{% img /static/imgs/建造者模式UML关系图.gif 建造者模式UML关系图 %}


举例：咱们来用建造者来演示一下美女换衣服吧。

````java 

//1. 先创建一个女孩类，其中包含换衣服和换鞋子【提供产品的属性】

import lombok.AllArgsConstructor;
import lombok.Data;
import lombok.NoArgsConstructor;
import lombok.ToString;

/**
 *
 * @author HJK
 * @date 2020/1/6 21:10
 */
@Data
@NoArgsConstructor
@AllArgsConstructor
@ToString
public class Girl {

    //衣服
    private String dress;

    //鞋子
    private String shoes;

}

//2. 然后创建一个女孩建造者抽象类,用于不同女孩的继承。【定义产品需要的材料】

/**
 * @author HJK
 * @date 2020/1/6 21:14
 */
public abstract class GirlBuilder {

    Girl girl = new Girl();

    /**
     * 换衣服
     */
    public abstract void buildDress();

    /**
     * 换鞋子
     */
    public abstract void buildShoes();

    /**
     * 换衣服鞋子完成，可以出去玩啦
     * @return
     */
    public Girl buildGirl(){
        return girl;
    }
}

//3. 定义一个Director（指挥者）构建一个使用Builder接口的对象。
//   它主要是用于创建一个复杂的对象。它主要有两个作用，一是：隔离了客户与对象的生产过程，
//   二是：负责控制产品对象的生产过程。【提供构建产品的顺序(封装过程)】

import lombok.AllArgsConstructor;
import lombok.Setter;

/**
 * @author HJK
 * @date 2020/1/6 21:16
 */
@AllArgsConstructor
public class GirlDirector {

    @Setter
    GirlBuilder girlBuilder;

    /**
     * 此方法用于规定建造的顺序，也就是说先换衣服还是先换鞋子
     * @return
     */
    public Girl girlConductor(){
        //换衣服
        girlBuilder.buildDress();
        //换鞋子
        girlBuilder.buildShoes();
        //可以出门了
        return girlBuilder.buildGirl();
    }

}

//4. 定义具体的女孩建造类，ConcreteBuilder（具体建造者）：实现接口，构建和装配各个部件。【提供构建产品的具体材料】

/**
 * 性感女孩的建造类
 * @author HJK
 * @date 2020/1/6 21:20
 */
public class SexGirlBuilder extends GirlBuilder {

    @Override
    public void buildDress() {
        System.out.println("性感女孩喜欢穿露肩杉+超短裙~");
    }

    @Override
    public void buildShoes() {
        System.out.println("性感女孩喜欢穿高跟鞋~");
    }
}

/**
 * 学生女孩建造类
 * @author HJK
 * @date 2020/1/6 21:23
 */
public class SchoolGirlBuilder extends GirlBuilder {

    @Override
    public void buildDress() {
        System.out.println("学生女孩必须穿校服");
    }

    @Override
    public void buildShoes() {
        System.out.println("学生女孩必须穿平底鞋");
    }
}

//5. 编写测试类，进行结果测试。

/**
 * @author HJK
 * @date 2020/1/6 21:24
 */
public class BuilderTest {

    public static void main(String[] args) {
        
        //构建性感女孩建造类,填充具体信息
        GirlBuilder girlBuilder = new SexGirlBuilder();

        //构建指挥官进行顺序处理
        GirlDirector girlDirector = new GirlDirector(girlBuilder);
        Girl girl1 = girlDirector.girlConductor();

    }
}

//6. 结果输出

性感女孩喜欢穿露肩杉+超短裙~
性感女孩喜欢穿高跟鞋~

````


## 原型模式（Prototype Pattern）


原型模式虽然是创建型的模式，但是与工程模式没有关系，从名字即可看出，该模式的思想就是将一个对象作为原型，对其进行复制、克隆，产生一个和原对象类似的新对象。本小结会通过对象的复制，进行讲解。在Java中，复制对象是通过clone()实现的。
具体类图如下：

{% img /static/imgs/原型模式UML类图.png 原型模式UML类图 %}

举例：以Java中的Clone为例

```java 

/**
 * 定义原型类
 * @author HJK
 * @date 2020/1/6 21:10
 */
public class Prototype implements Cloneable {  
  
    public Object clone() throws CloneNotSupportedException {  
        Prototype proto = (Prototype) super.clone();  
        return proto;  
    }  
}  

```

只需要实现Cloneable接口，覆写clone方法，此处clone方法可以改成任意的名称，因为Cloneable接口是个空接口，你可以任意定义实现类的方法名，如cloneA或者cloneB，因为此处的重点是super.clone()这句话，super.clone()调用的是Object的clone()方法，而在Object类中，clone()是native的，具体怎么实现，我会在另一篇文章中，关于解读Java中本地方法的调用，此处不再深究。在这儿，我将结合对象的浅复制和深复制来说一下，首先需要了解对象深、浅复制的概念：

浅复制：将一个对象复制后，基本数据类型的变量都会重新创建，而引用类型，指向的还是原对象所指向的。

深复制：将一个对象复制后，不论是基本数据类型还有引用类型，都是重新创建的。简单来说，就是深复制进行了完全彻底的复制，而浅复制不彻底。


# 结构型模式常用模式详解

这些设计模式关注类和对象的组合。继承的概念被用来组合接口和定义组合对象获得新功能的方式。本章主要阐述适配器模式和代理模式。主要包括的各种模式的关系图如下：

{% img /static/imgs/23种设计模式-结构型模式关系图.jpg 23种设计模式-结构型模式关系图 %}

## 适配器模式（Adapter Pattern）

适配器模式是作为两个不兼容的接口之间的桥梁，目的是消除由于接口不匹配所造成的类的兼容性问题。主要分为三类：类的适配器模式、对象的适配器模式、接口的适配器模式。

### 类的适配器模式

类的适配器是在适配类(Adaptee)拥有的方法基础上兼容目标接口(Target)中的方法。

{% img /static/imgs/适配器模式-类适配器UML类图.gif 适配器模式-类适配器UML类图 %}
 
```java 
//目标接口
interface Target
{
    public void request();
}
//适配者接口
class Adaptee
{
    public void specificRequest()
    {       
        System.out.println("适配者中的业务代码被调用！");
    }
}
//类适配器类
class ClassAdapter extends Adaptee implements Target
{
    public void request()
    {
        specificRequest();
    }
}
//客户端代码
public class ClassAdapterTest
{
    public static void main(String[] args){
        Target target = new ClassAdapter();
        target.request();
    }
}

```


### 对象的适配器模式

基本思路和类的适配器模式相同，只是将Adapter类作修改，这次不继承Adaptee类，而是持有Adaptee类的实例，以达到解决兼容性的问题。

{% img /static/imgs/适配器模式-对象适配器UML类图.gif 适配器模式-对象适配器UML类图 %}

```java 
//对象适配器类
public class ObjectAdapter implements Target
{
    private Adaptee adaptee;
    public ObjectAdapter(Adaptee adaptee)
    {
        this.adaptee=adaptee;
    }
    public void request()
    {
        adaptee.specificRequest();
    }
}
//客户端代码
public class ObjectAdapterTest
{
    public static void main(String[] args)
    {
        Adaptee adaptee = new Adaptee();
        Target target = new ObjectAdapter(adaptee);
        target.request();
    }
}
```

### 接口的适配器模式

有时我们写的一个接口中有多个抽象方法，当我们写该接口的实现类时，必须实现该接口的所有方法，这明显有时比较浪费，因为并不是所有的方法都是我们需要的，有时只需要某一些，此处为了解决这个问题，我们引入了接口的适配器模式，借助于一个抽象类，该抽象类实现了该接口，实现了所有的方法，而我们不和原始的接口打交道，只和该抽象类取得联系，所以我们写一个类，继承该抽象类，重写我们需要的方法就行。

{% img /static/imgs/适配器模式-接口适配器模式UML类图.png  适配器模式-接口适配器模式UML类图 %}

```java 
/**
 * 总体接口
 */
public interface Sourceable{
    void method1();
    void method2();
}

/**
 * 接口抽象类
 */
public abstract class Wrapper implements Sourceable{
    public void method1(){}
    public void method2(){}
}

/**
 * 具体实现类，仅实现需要的方法
 */
public class SourceSub1 extends Wrapper{

    @Override
    public void method1() {
        System.out.println("sub1_method1");
    }
}

/**
 * 具体实现类，仅实现需要的方法
 */
public class SourceSub2 extends Wrapper{

    @Override
    public void method2() {
        System.out.println("sub2_method2");
    }
}

/**
 * 测试类
 */
public class WrapperTest {
    public static void main(String[] args) {

        Sourceable s1 = new SourceSub1();
        s1.method1();
        s1.method2();
    }
}
```


## 装饰器模式（Decorator Pattern）

顾名思义，装饰模式就是给一个对象增加一些新的功能，而且是动态的，要求装饰对象和被装饰对象实现同一个接口，装饰对象持有被装饰对象的实例。直接看代码:

```java
 //Source类接口
public interface Sourceable {  
    public void method();  
}  

//具体实现类
public class Source implements Sourceable {  
  
    @Override  
    public void method() {  
        System.out.println("the original method!");  
    }  
}  

//装饰类
public class Decorator implements Sourceable {  
  
    private Sourceable source;  
      
    public Decorator(Sourceable source){  
        super();  
        this.source = source;  
    }  

    @Override  
    public void method() {  
        System.out.println("before decorator!");  
        source.method();  
        System.out.println("after decorator!");  
    }  
}  

//测试类
public class DecoratorTest {  
  
    public static void main(String[] args) {  
        Sourceable source = new Source();  
        Sourceable obj = new Decorator(source);  
        obj.method();  
    }  
}  

//测试结果
before decorator!
the original method!
after decorator!

```

## 代理模式（Proxy Pattern）

代理模式就是多一个代理类出来，替原对象进行一些操作，比如我们在租房子的时候回去找中介，为什么呢？因为你对该地区房屋的信息掌握的不够全面，希望找一个更熟悉的人去帮你做，此处的代理就是这个意思。代理模式也是框架设计最主要的模式之一。

{% img /static/imgs/代理模式UML类图.gif 代理模式UML类图 %}

```java 
//抽象主题
public interface Subject
{
    void Request();
}

//真实主题
public class RealSubject implements Subject
{
    public void Request()
    {
        System.out.println("访问真实主题方法...");
    }
}

//代理
public class Proxy implements Subject
{
    private RealSubject realSubject;
    public void Request()
    {
        if (realSubject == null)
        {
            realSubject = new RealSubject();
        }
        preRequest();
        realSubject.Request();
        postRequest();
    }
    public void preRequest()
    {
        System.out.println("访问真实主题之前的预处理。");
    }
    public void postRequest()
    {
        System.out.println("访问真实主题之后的后续处理。");
    }
}

//测试类
public class ProxyTest
{
    public static void main(String[] args)
    {
        Proxy proxy = new Proxy();
        proxy.Request();
    }
}

//测试结果
访问真实主题之前的预处理。
访问真实主题方法...
访问真实主题之后的后续处理。

```

## 桥接模式（Bridge Pattern）

桥接模式就是把事物和其具体实现分开，使他们可以各自独立的变化。桥接的用意是：将抽象化与实现化解耦，使得二者可以独立变化，像我们常用的JDBC桥DriverManager一样，JDBC进行连接数据库的时候，在各个数据库之间进行切换，基本不需要动太多的代码，甚至丝毫不用动，原因就是JDBC提供统一接口，每个数据库提供各自的实现，用一个叫做数据库驱动的程序来桥接就行了。


# 行为型模式常用模式详解

行为型模式有11种，这些设计模式特别关注对象之间的通信，它们之间主要有以下区别。

{% img /static/imgs/23种设计模式-行为型模式分类图.jpg 23种设计模式-行为型模式分类图 %}

## 模板模式（Template Pattern）

定义一个操作中的算法骨架，而将算法的一些步骤延迟到子类中，使得子类可以不改变该算法结构的情况下重定义该算法的某些特定步骤。

```java 
//1. 定义一个抽象计算类，包括一个抽象方法
public abstract class AbstractCalculator {  
      
    //模板方法：定义了算法的骨架，按某种顺序调用其包含的基本方法。
    public final int calculate(String exp,String opt){  
        int array[] = split(exp,opt);  
        return calculate(array[0],array[1]);  
    }  
      
    //抽象方法：在抽象类中申明，由具体子类实现。
    abstract public int calculate(int num1,int num2);  
      
    //具体方法：在抽象类中已经实现，在具体子类中可以继承或重写它。
    public int[] split(String exp,String opt){  
        String array[] = exp.split(opt);  
        int arrayInt[] = new int[2];  
        arrayInt[0] = Integer.parseInt(array[0]);  
        arrayInt[1] = Integer.parseInt(array[1]);  
        return arrayInt;  
    }  
}  

//2. 定义具体计算类的子类
public class Plus extends AbstractCalculator {  
  
    @Override  
    public int calculate(int num1,int num2) {  
        return num1 + num2;  
    }  
}  

//测试类
public class StrategyTest {  
  
    public static void main(String[] args) {  
        String exp = "8+8";  
        AbstractCalculator cal = new Plus();  
        int result = cal.calculate(exp, "\\+");  
        System.out.println(result);  
    }  
}  

```


## 观察者模式（Observer Pattern）

指多个对象间存在一对多的依赖关系，当一个对象的状态发生改变时，所有依赖于它的对象都得到通知并被自动更新。这种模式有时又称作发布-订阅模式、模型-视图模式。观察者模式很好理解，类似于邮件订阅和RSS订阅，当我们浏览一些博客或wiki时，经常会看到RSS图标，就这的意思是，当你订阅了该文章，如果后续有更新，会及时通知你。其实，简单来讲就一句话：当一个对象变化时，其它依赖该对象的对象都会收到通知，并且随着变化！对象之间是一种一对多的关系。

{% img /static/imgs/观察者模式UML类图.png 观察者模式UML类图 %}

```java 
//1. 定义观察者接口
public interface Observer {  
    public void update();  
}  

//2. 定义两个观察者实现类
public class Observer1 implements Observer {  
  
    @Override  
    public void update() {  
        System.out.println("observer1 has received!");  
    }  
}

public class Observer2 implements Observer {  
  
    @Override  
    public void update() {  
        System.out.println("observer2 has received!");  
    }  
}  

//3. 定义订阅话题接口
public interface Subject {  
      
    /*增加观察者*/  
    public void add(Observer observer);  
      
    /*删除观察者*/  
    public void del(Observer observer);  
      
    /*通知所有的观察者*/  
    public void notifyObservers();  
      
    /*自身的操作*/  
    public void operation();  
} 

//4. 定义话题接口实现类，用于维护多个话题需要

public abstract class AbstractSubject implements Subject {  
  
    private Vector<Observer> vector = new Vector<Observer>();  
    @Override  
    public void add(Observer observer) {  
        vector.add(observer);  
    }  
  
    @Override  
    public void del(Observer observer) {  
        vector.remove(observer);  
    }  
  
    @Override  
    public void notifyObservers() {  
        Enumeration<Observer> enumo = vector.elements();  
        while(enumo.hasMoreElements()){  
            enumo.nextElement().update();  
        }  
    }  
}  

//5.定义具体话题实现类
public class MySubject extends AbstractSubject {  
  
    @Override  
    public void operation() {  
        System.out.println("update self!");  
        notifyObservers();  
    }  
  
}  

//6. 测试
public class ObserverTest {  
  
    public static void main(String[] args) {  
        Subject sub = new MySubject();  
        //添加观察者监听对象
        sub.add(new Observer1());  
        sub.add(new Observer2());  
        //进行更新通知
        sub.operation(); 
    }  
}  

//7. 测试结果
update self!
observer1 has received!
observer2 has received!

```

## 状态模式（State Pattern）

对有状态的对象，把复杂的“判断逻辑”提取到不同的状态对象中，允许状态对象在其内部状态发生改变时改变其行为。核心思想就是：当对象的状态改变时，同时改变其行为，很好理解！就拿QQ来说，有几种状态，在线、隐身、忙碌等，每个状态对应不同的操作，而且你的好友也能看到你的状态，所以，状态模式就两点：1、可以通过改变状态来获得不同的行为。2、你的好友能同时看到你的变化。

{% img /static/imgs/状态模式UML类图.gif 状态模式UML类图 %}

```java 
//环境类
public class Context
{
    private State state;
    //定义环境类的初始状态
    public Context()
    {
        this.state=new ConcreteStateA();
    }
    //设置新状态
    public void setState(State state)
    {
        this.state=state;
    }
    //读取状态
    public State getState()
    {
        return(state);
    }
    //对请求做处理
    public void Handle()
    {
        state.Handle(this);
    }
}
//抽象状态类
public abstract class State
{
    public abstract void Handle(Context context);
}
//具体状态A类
public class ConcreteStateA extends State
{
    public void Handle(Context context)
    {
        System.out.println("当前状态是 A.");
        context.setState(new ConcreteStateB());
    }
}
//具体状态B类
public class ConcreteStateB extends State
{
    public void Handle(Context context)
    {
        System.out.println("当前状态是 B.");
        context.setState(new ConcreteStateA());
    }
}

//测试类
public class StatePatternClient
{
    public static void main(String[] args)
    {       
        Context context=new Context();    //创建环境       
        context.Handle();    //处理请求
        context.Handle();
        context.Handle();
        context.Handle();
    }
}

//测试结果
当前状态是 A.
当前状态是 B.
当前状态是 A.
当前状态是 B.

```

## 中介者模式（Mediator Pattern）

定义一个中介对象来封装一系列对象之间的交互，使原有对象之间的耦合松散，且可以独立地改变它们之间的交互。中介者模式又叫调停模式，它是迪米特法则的典型应用。

{% img  /static/imgs/中介者模式UML类图.gif 中介者模式UML类图 %}

```java 
//抽象中介者
public abstract class Mediator
{
    public abstract void register(Colleague colleague);
    public abstract void relay(Colleague cl); //转发
}

//具体中介者
public class ConcreteMediator extends Mediator
{
    private List<Colleague> colleagues=new ArrayList<Colleague>();
    public void register(Colleague colleague)
    {
        if(!colleagues.contains(colleague))
        {
            colleagues.add(colleague);
            colleague.setMedium(this);
        }
    }
    public void relay(Colleague cl)
    {
        for(Colleague ob:colleagues)
        {
            if(!ob.equals(cl))
            {
                ((Colleague)ob).receive();
            }   
        }
    }
}

//抽象同事类
public abstract class Colleague
{
    protected Mediator mediator;
    public void setMedium(Mediator mediator)
    {
        this.mediator=mediator;
    }   
    public abstract void receive();   
    public abstract void send();
}

//具体同事类
public class ConcreteColleague1 extends Colleague
{
    public void receive()
    {
        System.out.println("具体同事类1收到请求。");
    }   
    public void send()
    {
        System.out.println("具体同事类1发出请求。");
        mediator.relay(this); //请中介者转发
    }
}

//具体同事类
public class ConcreteColleague2 extends Colleague
{
    public void receive()
    {
        System.out.println("具体同事类2收到请求。");
    }   
    public void send()
    {
        System.out.println("具体同事类2发出请求。");
        mediator.relay(this); //请中介者转发
    }
}

//测试类
public class MediatorPattern
{
    public static void main(String[] args)
    {
        Mediator md=new ConcreteMediator();
        Colleague c1,c2;
        c1=new ConcreteColleague1();
        c2=new ConcreteColleague2();
        md.register(c1);
        md.register(c2);
        c1.send();
        System.out.println("-------------");
        c2.send();
    }
}

//测试结果
具体同事类1发出请求。
具体同事类2收到请求。
-------------
具体同事类2发出请求。
具体同事类1收到请求。

```


# 总结 

以上举例阐述了常用的设计模式和具体实现。其他模式的实现有机会再补充。充分理解各大设计模式对于阅读源码及程序设计方面会有较大帮助。
推荐以下设计模式文章的链接，本文也参考了以下的文章：

{% blockquote Java开发中的23种设计模式详解(转) https://www.cnblogs.com/maowang1991/archive/2013/04/15/3023236.html %}{% endblockquote %}
{% blockquote 软件设计模式概述 http://c.biancheng.net/view/1317.html %}{% endblockquote %}
{% blockquote 设计模式简介 https://www.runoob.com/design-pattern/design-pattern-intro.html %}{% endblockquote %}

